# Generated by Django 4.2.17 on 2025-11-05 17:51
# Updated to safely handle existing month column and unique constraints

from django.db import migrations, models


def check_column_exists(schema_editor, table_name, column_name):
    """Check if a column exists in the table"""
    from django.db import connection
    
    with connection.cursor() as cursor:
        if connection.vendor == 'mysql':
            cursor.execute("""
                SELECT COUNT(*) 
                FROM information_schema.COLUMNS 
                WHERE TABLE_SCHEMA = DATABASE() 
                AND TABLE_NAME = %s 
                AND COLUMN_NAME = %s
            """, [table_name, column_name])
        else:
            cursor.execute("""
                SELECT COUNT(*) 
                FROM information_schema.COLUMNS 
                WHERE TABLE_NAME = %s 
                AND COLUMN_NAME = %s
            """, [table_name, column_name])
        
        return cursor.fetchone()[0] > 0


def ensure_month_column(apps, schema_editor):
    """Ensure month column exists, skip if it already does"""
    table_name = 'inspections_compliancequota'
    column_name = 'month'
    
    if not check_column_exists(schema_editor, table_name, column_name):
        from django.db import connection
        with connection.cursor() as cursor:
            if connection.vendor == 'mysql':
                cursor.execute("""
                    ALTER TABLE inspections_compliancequota 
                    ADD COLUMN month INT NULL
                """)
                # Update any NULL values
                cursor.execute("""
                    UPDATE inspections_compliancequota 
                    SET month = CASE 
                        WHEN quarter = 1 THEN 1
                        WHEN quarter = 2 THEN 4
                        WHEN quarter = 3 THEN 7
                        WHEN quarter = 4 THEN 10
                        ELSE 1
                    END
                    WHERE month IS NULL
                """)
                # Make NOT NULL
                cursor.execute("""
                    ALTER TABLE inspections_compliancequota 
                    MODIFY COLUMN month INT NOT NULL
                """)
            else:
                cursor.execute("""
                    ALTER TABLE inspections_compliancequota 
                    ADD COLUMN month INTEGER NOT NULL DEFAULT 1
                """)


def update_unique_constraint(apps, schema_editor):
    """Update unique constraint to use month instead of quarter"""
    from django.db import connection
    
    table_name = 'inspections_compliancequota'
    
    with connection.cursor() as cursor:
        # Try common constraint names and remove them if they exist
        old_constraint_names = [
            'inspections_compliancequota_law_year_quarter_uniq',
            'inspections_compliancequota_law_year_quarter_unique',
        ]
        
        for old_constraint in old_constraint_names:
            if connection.vendor == 'mysql':
                cursor.execute("""
                    SELECT COUNT(*) 
                    FROM information_schema.STATISTICS 
                    WHERE TABLE_SCHEMA = DATABASE() 
                    AND TABLE_NAME = %s 
                    AND INDEX_NAME = %s
                    AND NON_UNIQUE = 0
                """, [table_name, old_constraint])
            else:
                cursor.execute("""
                    SELECT COUNT(*) 
                    FROM information_schema.STATISTICS 
                    WHERE TABLE_NAME = %s 
                    AND INDEX_NAME = %s
                    AND NON_UNIQUE = 0
                """, [table_name, old_constraint])
            
            result = cursor.fetchone()
            if result and result[0] > 0:
                try:
                    cursor.execute("ALTER TABLE {} DROP INDEX {}".format(table_name, old_constraint))
                except Exception:
                    pass  # Ignore if it doesn't exist or has different structure
        
        # Add new unique constraint if it doesn't exist
        new_constraint = 'inspections_compliancequota_law_year_month_uniq'
        if connection.vendor == 'mysql':
            cursor.execute("""
                SELECT COUNT(*) 
                FROM information_schema.STATISTICS 
                WHERE TABLE_SCHEMA = DATABASE() 
                AND TABLE_NAME = %s 
                AND INDEX_NAME = %s
                AND NON_UNIQUE = 0
            """, [table_name, new_constraint])
        else:
            cursor.execute("""
                SELECT COUNT(*) 
                FROM information_schema.STATISTICS 
                WHERE TABLE_NAME = %s 
                AND INDEX_NAME = %s
                AND NON_UNIQUE = 0
            """, [table_name, new_constraint])
        
        result = cursor.fetchone()
        if not result or result[0] == 0:
            cursor.execute("ALTER TABLE {} ADD UNIQUE KEY {} (law, year, month)".format(table_name, new_constraint))


def reverse_update_unique_constraint(apps, schema_editor):
    """Reverse: restore old unique constraint"""
    from django.db import connection
    
    table_name = 'inspections_compliancequota'
    new_constraint = 'inspections_compliancequota_law_year_month_uniq'
    old_constraint = 'inspections_compliancequota_law_year_quarter_uniq'
    
    with connection.cursor() as cursor:
        # Remove new constraint
        if connection.vendor == 'mysql':
            cursor.execute("""
                SELECT COUNT(*) 
                FROM information_schema.STATISTICS 
                WHERE TABLE_SCHEMA = DATABASE() 
                AND TABLE_NAME = %s 
                AND INDEX_NAME = %s
            """, [table_name, new_constraint])
        else:
            cursor.execute("""
                SELECT COUNT(*) 
                FROM information_schema.STATISTICS 
                WHERE TABLE_NAME = %s 
                AND INDEX_NAME = %s
            """, [table_name, new_constraint])
        
        result = cursor.fetchone()
        if result and result[0] > 0:
            cursor.execute("ALTER TABLE {} DROP INDEX {}".format(table_name, new_constraint))
        
        # Restore old constraint
        if connection.vendor == 'mysql':
            cursor.execute("""
                SELECT COUNT(*) 
                FROM information_schema.STATISTICS 
                WHERE TABLE_SCHEMA = DATABASE() 
                AND TABLE_NAME = %s 
                AND INDEX_NAME = %s
            """, [table_name, old_constraint])
        else:
            cursor.execute("""
                SELECT COUNT(*) 
                FROM information_schema.STATISTICS 
                WHERE TABLE_NAME = %s 
                AND INDEX_NAME = %s
            """, [table_name, old_constraint])
        
        result = cursor.fetchone()
        if not result or result[0] == 0:
            cursor.execute("ALTER TABLE {} ADD UNIQUE KEY {} (law, year, quarter)".format(table_name, old_constraint))


class Migration(migrations.Migration):

    dependencies = [
        ('inspections', '0010_remove_compliancequota_inspections_law_bed71c_idx_and_more'),
    ]

    operations = [
        # Ensure month column exists (skip if already exists)
        migrations.RunPython(ensure_month_column, migrations.RunPython.noop),
        # Update unique constraint in database (this handles removing old and adding new)
        migrations.RunPython(update_unique_constraint, reverse_update_unique_constraint),
        # Update metadata to reflect new unique_together
        # We use SeparateDatabaseAndState to only update Django's state, not the database
        migrations.SeparateDatabaseAndState(
            # Don't change database - we already did that above
            database_operations=[],
            # Only update Django's state
            state_operations=[
                migrations.AlterUniqueTogether(
                    name='compliancequota',
                    unique_together={('law', 'year', 'month')},
                ),
            ]
        ),
    ]
